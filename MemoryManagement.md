# Управление памятью в iOS

В процессе запуска приложения операционная система выделяет ему виртуальное адресное пространство, где в дальнейшем могут храниться данные.

> Отмечу, что приложение работает именно с __виртуальным__ пространством, а не физическим. 

#### Страницы (page)

Пространство в памяти выделяется страницами (page) и всегда кратно 16 КБ (размеру одной страницы). Виртуальные адреса, используемые для доступа к страницам памяти, переводятся в адреса физической оперативной памяти с помощью таблицы `page table`.

#### Перерасход памяти

Если приложение используется слишком много памяти, то iOS отправит ему соответствующее предупреждение. При этом могут быть выполнены следующие действия:

- Для приложений в фоне read-only объекты, которые уже хранятся на диске, могут быть удалены из памяти, так как без проблем могут быть загружены в дальнейшем (кодоввые страницы, файлы, различные ресурсы и т.д.).
- Система вызывает метод `applicationDidReceiveMemoryWarning` делегата приложения, в котором __должны__ освобождаться как можно больше ресурсов из памяти (например удаляться кэши). Если приложение не реагирует на данный метод, то оно может быть незамедлительно закрыто.
- Приложение закрывается, чтобы освободить используемую им память.

## Структура памяти

Виртуальное адресное пространство процесса поделено на следующие области (указанны в порядке следования в памяти):

1. Инструкции, код программы.
- Глобальные данные.
- Куча (Heap).
- Пустое пространство, куда при необходимости расширяются куча и стек.
- Стек (Stack).

Экземпляры всех объектов, которые мы создаем в процессе разработки приложения (классы, структуры, функции, перечисления, кортежи и т.д.), хранятся в Куче и Стеке. Это две принципиально разные структуры, со своими "законами" и "правилами".

### <a id="stack"></a>Стек

Стек в виртуальной памяти функционирует на основе структуры данных `Stack` и принципа FIFO (First in, Last Out - Первый пришел, последний ушел). Все объекты, помещенные в стек, удаляются в обратно порядке. Определение размера выделяемой в стеке памяти происходит еще во время компиляции программного кода.

> В случае многопоточной работы приложения каждый поток (thread) имеет свой собственный стек.

Стек предназначен для хранения значимых типы (value type): структур (`struct`), перечислений (`enum`) и кортежей (`tuple`). 

> Есть частные случаи, когда значение value type хранится в куче. Подробнее тут.

#### Фреймы

Как только в программе появляется новая область видимости (scope), например вызывается метод или выполняется иттерация цикла, в стеке создается новый фрейм (frame), то есть выделяется память, необходимая данной области видимости для хранения данных. Для выполнения операции выделения требуется всего 1 процессорная инструкция, перемещающая указатель на указанный адрес. Именно по этой причине работа со стеком является очень дешевой с точки зрения производительности операцией.

Как только область видимости завершает свою работу ее фрейм удаляется. И вновь это происходит с помощью всего одной операции перемещения указателя.

### <a id="heap"></a>Куча

Каждый экземпляр, хранящийся в куче, является незаввисимым от других. Доступ к экземплярам производится по ссылке.

Куча позволяет выделять память динамически прямо во время исполнения программы.

> В случае многопоточной работы приложения куча является общей для всех потоков (threads).

Куча предназначен для хранения ссылочных типов (reference type): классов (`class`) и замыканий (`closure`).

#### Подсчет ссылок

Для того, чтобы эффективно ввыделять и удалять пространство в куче необходимо производить подсчет количества ссылок на объекты. При разработке под iOS используются две системы подсчета количества: MRC и ARC.

#### <a id="mrc"></a>Manual Reference Counting (MRC)

При разработке iOS приложений на языке Objective-C используется MRC, то есть система ручного подсчета ссылок. При создании объектов с помощью методов `new`, `copy` (и др.) счетчик ссылок на объект увеличивается на 1. При вызове метода `release` счетчик ссылок уменьшался на 1. Как только счетчик ссылок на объект становится равным нулю, он удаляется из кучи.

> При многопоточной работе приложения объект удаляется на том потоке, где был произведен последний `release`.

#### <a id="arc"></a>Automatic Reference Counting (ARC)

Swift, в отличии от Objective-C, использует систему автоматического подсчета ссылок (ARC). В процессе компиляции компилятор автоматически расставляет вызоыве методов, увеличивающих и уменьшающих количество ссылок. А в процессе функционироввания приложения ARC постоянно мониторит количество ссылок. Как и в случае с MRC, как только счетчик ссылок становится равным нулю - объект удаляется.

#### <a id="autoreleasepool"></a>Autorelese Pool

Autorelease pool - это хранилище объектов ссылочного типа, которые необходимо уничтожить не прямо сейчас, а несколько позже. В некоторых случаях требуется отложить уменьшение счетчика, например при возвращении объекта из функции. Так, если в конце функции вызвать `release` у возвращаемого объекта, то он будет уничтожен еще до того, как функция завершит работу. Но нам требуется, чтобы объект продолжал жить даже после завершения работы функции. Для таких ситуаций (когда нужно отложить уменьшение счетчика ссылок) существует метод `autorelease`. При его использовании вместо `release` данный объект помечается, как требующий уменьшения счетчика ссылок, но не сейчас, а несколько позже. Помеченный с помощью `autorelease` объект помещается в специальный autorelease pool.

Autorelease создается в начале каждой иттерации [RunLoop](/RunLoop.md) и обрабатывает все хранящиеся в нем объекты (уменьшает их счетчик ссылок) в конце этой иттерации. Для очищения autorelease pool вызывается его метод `drain`.

Данная система активно использовалась во времена использования MRC. Сегодня существует ARC и autorelease pool напрямую может использоваться только для ObjC-объектов, или объектов, помеченных с помощью аттрибута `@autorelease` (например `UIImage`). В большинстве случаев вам не стоит думать о нем, Swift все делает автоматически.

__Пример использования autorelease__

```swift
autoreleasepool {
    // ...
}

// пример
// все параметры image всех иттераций цикла будут храниться до конца жизни потока
// хотя в этом нет необходимости
// В результате. вприложении будет огромный перерасход памяти
for i in 1...1000 {
    let image = UIImage(named: "\(i).jpg")
    // ... сохранение файла в БД
    // по сути image больше не нужен
}

// с помощью autoreleasepool значение параметр image будет удаляться 
// в конце каждой иттерации цикла
for i in 1...1000 {
    autoreleasepool {
        let image = UIImage(named: "\(i).jpg")
        // ... сохранение файла в БД
    }
}
```

### В каких случаях value type хранится в куче



## Связанный контент

- [Выбор между `struct` и `class`](./StructClassChoise.md)


## Дополнительная информация

- [Memory Management in Swift: Heaps & Stacks](https://heartbeat.fritz.ai/memory-management-in-swift-heaps-stacks-baa755abe16a)
- [Classes vs. Structs in Swift — Basics and Memory Management](https://betterprogramming.pub/classes-vs-structs-basics-and-memory-management-4707714d82e)