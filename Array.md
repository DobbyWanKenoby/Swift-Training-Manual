# Массивы

## Содержание

- [Описание](#description)
- [Операции](#operations)
	- [Создание массива](#initial)
	- [Доступ к элементам](#access)
	- [Операции со значениями](#operationswithvalues)
	- [Сортировка и фильтрация](#sort)

## <a id="description"></a>Описание
Массив позволяет организовать множество элементов в единое значение, в котором элементы упорядочены и могут быть получены напрямую с помощью индексов.

### Типы данных

При работе с массивами используются следующие типы данных:

- `Array`
- `ContiguousArray`
- `ArraySlice`
- `NSArray`
- `NSMutableArray`

### <a id="array"></a>Тип `Array`

### <a id="contiguousarray"></a>Тип `ContiguousArray`

### <a id="arrayslice"></a>Тип `ArraySlice`

### <a id="nsarray"></a>Тип `NSArray`

### <a id="nsmutablearray"></a>Тип `NSMutableArray`

## <a id="operations"></a>Операции

### Исходные данные

Многие из описываемых далее операции будем производить со следующими массивами:

```swift
// плоский массив
var sourceArray = [1, 2, 3, 4, 5]
// многомерный массив
var matrixArray = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]
// массив с опционалами
var optionalArray: Array<Int?> = [ nil, 2, nil, 4, nil, 6]

// структура для хранения в массиве
struct Man {
    var name: String
    var age: Int
}
// массив для хранения структуры
var structArray = [
    Man(name: "Bazil", age: 30),
    Man(name: "Alex", age: 42),
    Man(name: "Helga", age: 21)]
```

#### Сокращенные синтаксис

Во многих из перечисленных методов используется сокращенный синтаксис для доступа к элементам вид `$N`, где `N` - целое число. С помощью значений такого вида внутри замыканий осуществляется доступ к входным параметрам: `$0` - к первому, `$1` - ко второму и т.д.

### Инициализация

Обычно для создания массива используют тип `Array`, но если вы уверены, что элементы массива не будут классами или протоколами `@objc`, то для оптимизации можно использовать `ContiguousArray`. В ином случае `Array` сам примет решение о том, значение какого типа ему создать (`NSArray` или `ContiguousArray`).

##### <a id="initial"></a>Создание массива

```swift
// 1
// Массив может быть создан с помощью облегченного синтаксиса

var numberArray = [1, 2, 3]
// в этом случае тип массива определяется автоматически
// на основании типа переданных элементов
// в массиве будут содержаться три значения типа Int

// для созданяи пустого массива можно использовать
var emptyArray = [Double]()
// в данный массив могут быть добавлены только элементы типа Double

// 2
// Массив может быть создан с помощью ключевого слова Array

// массив с 2 элементами типа Character
var alphArray = Array(arrayLiteral: Character("a"), "b")

// массив с одинаковыми элементами
var repeatingArray = Array(repeating: 0, count: 3) // [0, 0, 0]

// массив на основе диапазона
var arrayFromRange = Array(1...4) // [1, 2, 3, 4]

// массив на основе последовательности
var set = Set(arrayLiteral: 1,3,2)
var arrayFromSet = Array(set)
// в данном случае итоговый порядок элементов в массиве
// будет изменяться при каждом исполнении кода
// он зависит от хэшей элементов (протокол Hashable)

// 3
// Массив может быть создан с помощью указания полного типа данных

// массив с 3 элементами типа Float
var floatArray: Array<Float> = [1, 2, 3]

// массив c 2 элнементами типа Character
var stringArray = Array<Character>(arrayLiteral: "a", "b")
```

### <a id="access"></a>Доступ к элементам

##### Получить элемент по индексу

```swift
sourceArray[2] // 3
```

##### Получить количество элементов

__Свойство `count`__ возвращает количество элементов в массиве.

```swift
sourceArray.count // 5
```

##### Получить индекс первого/последнего подходящего элемента

__Методы групп `firstIndex` и `lastIndex`__ позволяют получить индекс первого элемента, подходящего под условия.

```swift
// firstIndex
sourceArray.firstIndex(of: 2) // 1

let findex = sourceArray.firstIndex(where: { $0 > 2 })
findex // 2

// lastIndex
sourceArray.lastIndex(of: 3) // 2

let lindex = sourceArray.lastIndex(where: { $0 < 3 })
lindex // 1
```

##### Получить первый элемент

__Метод `first`__ возвращает опционал, так как массив может не содержать элементов.

```swift
sourceArray.first // Oprional(1)
```

##### Получить последний элемент

__Метод `last`__ возвращает опционал, так как массив может не содержать элементов.

```swift
sourceArray.last // Optional(5)
```

##### Получить максимальный и минимальный элементы

__Методы `max` и `min`__ возвращают опциональное максимальное и минимальное значения. При этом для них возможно указать условие предварительной сортировки элементов.

```swift
// получения большего элемента без условий
sourceArray.max()
// получение большего элемента с предвварительной сортировкой
let man = structArray.max(by: { $0.age < $1.age }) //
man?.age // экземпляр с age = 42
```

> Метод `min` работает аналогичным образом.

##### Получить первый элемент, соответствующий условию

Вы можете указать произвольное условие для поиска элемента

```swift
// первый элемент со значением больше 3
sourceArray.first(where: { $0 > 3 }) // Optional(4)
```

### <a id="operationswithvalues"></a>Операции со значениями

##### Вставка элемента в конец массива

__Метод `append(_:)`__ добавляет элемент в конец массива.

```swift
sourceArray.append(8) // [1, 2, 3, 4, 5, 8]
```

##### Вставка элемента на указанную позицию

__Метод `insert(_:at:)`__ вставляет переданный элемент на указанную позицию. При этом все последующие элементы сдвигаются на одну позицию вправо.

```swift
optionalArray.insert(99, at: 3) // [nil, 2, nil, 99, 4, nil, 6]
```

##### Удаление элемента с указанным индексом

__Метод `remove(at:)`__ возвращает удаленный элемент. В качестве аргумента передается индекс удаляемого элемента.

```swift
sourceArray.remove(at: 0) // 1
sourceArray // [2, 3, 4, 5]
```

##### Удаление всех элементов

__Метод `removeAll()`__ удаляет все элементы массива.

```swift
sourceArray.removeAll() // []
```

##### Удаление всех элементов, подходящих по условие

```swift

```

##### Обработка всех элементов массива

__Метод `map`__ позволяет применить переданный обработчик к каждому элементу массива. Может возвращать опциональные значения.

```swift
let editArray = sourceArray.map { $0 + 1 }
editArray // [2, 3, 4, 5, 6]
    
let anotherEditArray = optionalArray.map { $0 }
anotherEditArray // [nil, 2, nil, 4, nil, 6]
```
##### Обработка всех элементов массива, исключая опциональные

__Метод `compactMap`__ очень похож на `map` за тем исключением, что он возвращает только неопциональные значения.

```swift
let editArray = optionalArray.compactMap { $0 }
editArray // [2, 4, 6]
```

### <a id="sort"></a>Сортировка и фильтрация значений

##### Сортировка значений

__Метод `sort`__ сортирует элементы исходного массива в соответствии с переданным условием.

```swift
// сортировка по возрастанию
structArray.sort { $0.age < $1.age }
structArray // [{name "Helga", age 21}, {name "Bazil", age 30}, {name "Alex", age 42}]
```

__Метод `sorted`__ возвращает новый массив, в котором элементы отсортированы в соответствии с переданным условием.

```swift
let newArray = sourceArray.sorted(by: {
    $0 > $1
})
newArray // [5, 4, 3, 2, 1]
```

##### Фильтрация значений

__Метод `filter`__ возвращает новывй массив, состоящий из тех элементов, для которых переданное замыкание возвращает `true`.

```swift
let men = structArray.filter { $0.age > 29 }
// содержатся все элементы с age > 29
men // [{name "Bazil", age 30}, {name "Alex", age 42}]
```



```swift

```


## Дополнительная информация

- [Документация к типу `Array`](https://developer.apple.com/documentation/swift/array)
- [Документация к типу `NSArray`](https://developer.apple.com/documentation/foundation/nsarray)
- [Исходный код типа `Array`](https://github.com/apple/swift/blob/main/stdlib/public/core/Array.swift)
- [Исходный код типа `ContiguousArray`](https://github.com/apple/swift/blob/main/stdlib/public/core/ContiguousArray.swift)