# KVO & KVC

[К оглавлению](./README.md)

## Содержание

- [KVC](#kvc)
- [KVO](#kvo)

## Описание

Механизмы KVC и KVO позволяют получать доступ (для чтения и записи) к свойствам **классов**, а также наблюдать за изменениями их значений для осуществления асинхронной реакции на эти изменения.

> ПРИМЕЧАНИЕ
>
> Данные механизмы являются устаревшими, так как используют Objective-C Runtime и требуют использования класса `NSObject`. Тем не менее они все еще используются, в частности под капотом Interface Builder при привязке свойств вью контроллера к элементам на сцене.

Механизмы KVC и KVO использую Objective-C runtime, по этой причине при работе с ними необходимо помечать свойства класса с помощью аттрибута `@objc`. Так же для "включения" динамической диспетчеризации используется ключевое слово `dynamic`.
 
##  <a id="kvc"></a>KVC (Key-Value Coding)

### Описание

KVC предоставляет механизм обращения к свойствам класса (для их чтения или изменения) , используя строковые значения вместо привычного синтаксиса, когда название свойства указывается через точку. Основная особенность в том, что имя свойства, к которому происходит обращение, определяется динамически прямо во время исполнения приложения (через Objective-C Runtime), а не на этапе компиляции.

### Использование KVC

#### Создание свойства

Свойство, для которого будет использоваться KVC-синтаксис, должно быть помечено с помощью аттрибута [`@objc`](/Ch-ObjectiveCRuntime.md#objc) и ключевого слова `dynamic`. Класс, в состав которого он входит, должен наследоваться от `NSObject`.

```swift
class Pokemon: NSObject {
	@objc dynamic var name: String = ""
}
```

#### Операции со свойством

Для доступа к свойству используется метод `value(forKey:)`.

```swift
let pockemonName = pockemon.value(forKey: "name")
```

Для изменения значения свойство используется метод `setValue(_:forKey:)`.

```swift
let pockemonName.setValue("Pikachu", forKey: "name")
```

## <a id="kvo"></a>KVO - Key-Value Observing

### Описание

KVO предоставляет механизм создания наблюдателей, определяющих реакцию на изменения значений свойств класс, наследуюемого от `NSObject`.

### Использование KVO

#### Создание наблюдаемого свойства

Свойство, для которого будет создан наблюдатель, должно быть помечено с помощью аттрибута `@objc` и ключевого слова `dynamic`. Класс, в состав которого он входит, должен наследоваться от `NSObject`.

```swift
// Вариант 1
// Слежение за свойством некоторой модели
class Person: NSObject {
	@objc dynamic var name = ""
}

// Вариант 2
// Слежение за собственным свойством вью контроллера
class ViewController: UIViewController {
	// ...
	@objc dynamic var isEnabled = false
	// ...
}
```

> ПРИМЕЧАНИЕ
>
> В случае, если слежение происходит за свойством некоторой внешней модели, как `Person.name` в примере выше, то экземпляр данной модели должен содержать в свойстве с аттрибутом `@objc`, например:

> ```swift
> class ViewController: UIViewController {
> 	// ...
>	@objc var person = Person()
>	// ...
> }
> ```

#### Создание наблюдателя

Для создания наблюдателя используется метод observe (входит в класс `NSObject`).

```swift
// Вариант 1
observe( %KeyPath свойства, для которого создается наблюдатель%,
	changeHadler: %замыкание, определяющее действия при изменении значения наблюдаемого свойства%)

// Вариант 2
observe( %KeyPath свойства, для которого создается наблюдатель%,
	options: [ %массив опциой, определяющий передаваемые данные% ],
	changeHadler: %замыкание, определяющее действия при изменении значения наблюдаемого свойства%)
```

> ПРИМЕЧАНИЕ
>
> Метод `observe` не производит сохранение наблюдателя в каком-либо стороннем хранилище, а созданное значение удаляется при выходе из области видимости (scope) ! Для его работы необходимо сохранить результат вызова`observe` во внешней области видимости, например как свойство вью контроллера.

#### Пример

```swift
observe( \ViewController.person.name,
	options: [ .new, .old, initial, prior ]) { vc, changedObject in 
	print("Новое значение: \(changedObject.newValue)")
	print("Старое значение: \(changedObject.oldValue)")
}
```